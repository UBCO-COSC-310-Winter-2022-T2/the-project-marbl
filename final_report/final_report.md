# General Development:

 ### **What did your team build? Is it feature complete and running?**
Our team built Clack; a discord clone and desktop application. Clack uses a client-server model where it communicates with a MQTT server to ensure real-time updates of chats and friend requests. The program offers some of the features of Discord like adding/removing friends, and communication through graph chats. Additionally, all of our data is persistent and stored in a database. Clack is running great, however there are a few features which were not compelted in time. 
# TODO: mention features not done above ^ and below v

 ### **How many of your initial requirements that your team set out to deliver did you actually deliver (a checklist/table would help to summarize)?  Were you able to deliver everything or are there things missing?  Did your initial requirements sufficiently capture the details needed for the project?**
Here is a list of our initial requirements (✔️ means delivered, ❌ means not delivered):

INITIAL FUNCTIONAL REQUIREMENTS:
* Create Account ✔️
* Login ✔️
* Logout ✔️
* Add Friend
* Remove Friend
* Create Group
* View Online Users
* Kick Member
* Leave Group
* Add User To Group
* Send Message ✔️
* View Group Messages
* View Direct Messages
* Password Recovery ✔️

INITIAL NON-FUNCTIONAL REQUIREMENTS:
* Adhere to Kanban process ✔️
    * Use a Trello board ✔️
    * Have weekly meetings on Wednesday and Friday ✔️
* Program must run on Windows 10+ ✔️
* Program must be made to run in Python 3.10 ✔️
* Chat history must be stored indefinetly ✔️
* A message sent by another user must be received in <= 1 second ✔️
* Files and images can be shared
* All private information is kept confidential ✔️
* User account must be linked to a valid email address ✔️
* The system must be able to handle 1000+ online users at a time
* Viewing the online status of a friend should take <= 1 click to view
* System must not allow two accounts with the same username ✔️


We had too many initial requirements as our team underestimated the work required to complete them. The time constraint turned out to be too tight therefore there are a few functional and non-functional requirements we had to leave out. In general, the requirements were fairly accurate to the final system and captured some details well. However, in making this system all of us were venturing into a relatively new domain of development which limited our ability to choose technologies and architectures beforehand. It is clear a waterfall process would not be effective at all for this project and the flexibility of the agile development process was instrumental to our success.

All of us learned new technologies over the course of the development of the application as a result of agile. Such technologies include Python packages, Pytest, MQTT and Mosquitto, firebase's authentication and realtime database services, PyQt5's UI library, PlantUML, and Github actions. Some of these technologies (particularily dealing with python packages, pytest, and Github actions) ended up taking large portions of time to debug (up to 80% of the time for some group members, particularly since any errors generated by our python packages importing one another would throw "module X does not exist," which is not particularly helpful when the solution is that we had not installed the application yet using python or we were missing an init file).
 ### **What is the architecture of the system?  What are the key components?   What design patterns did you use in the implementation?  This needs to be sufficiently detailed so that the reader will have an understanding of what was built and what components were used/created.  You will need to reflect on what you planned to build vs what you built.**

![our architecture diagram](clack_architecture_diagram.png)

Our architecture consists of four key components (only two of which we needed to program):

* The Client, which is what the user will interact with. Its responsibilities include sending messages over the MQTT network to other clients, querying the database to populate the session's variables on log in (since storing every user's chat messages locally is a security risk), and having an interface for the user to interact with the underlying system
* The MQTT broker, which simply forwards any messages to whoever is subscribed to the topic
* The Listener Server, who's responsibility is to listen for any messages being sent over the MQTT network and save them to the database (that way offline users can recieve messages). Having the Listener Server perform inserts on the database as opposed to the Client improves security by preventing a hacked client to insert bad data into the database
* Firebase, who is responsible for holding our database and perform the authentication of users. The Client uses the authentication service of Firebase to authenticate users as well as queries the database. The Listener Server performs inserts on the database

![our Client class diagram](../diagrams/out/class_diagram/class_diagram.png)

![our Listener Server class diagram](../diagrams/out/class_diagram_serverlistener/class_diagram_serverlistener.png)

The design patterns we used are the following:

* A singleton for the database connection to avoid creating a new connection to the database every time we want to use it. This improves performance by reducing network traffic
* A singleton for the MQTT connection to avoid creating a new connection to the MQTT network every time we want to use it. This improves performance by reducing network traffic
* A singleton for the Session Manager to ensure there is only one session at any given time (the session class holds the variable for whoever is logged in and all of their chats and is what the UI interacts with), and avoiding creating a new session every time something needs to be displayed improves performance considerably (the session's variables would need to be re-populated each time otherwise). Additionally, the SessionManager will automatically refresh the session since firebase will automatically close the session after one hour
* A publisher/subscriber model for the MQTT broker, which allows clients to subscribe to chatrooms (or other topics, like the statuses of their friends) in a low-coupling fashion, improving performance and reducing complexity

 ### **What degree and level of re-use was the team able to achieve and why?**

The degree and level of re-use we achieved was about average we think, it definitely could be improved, however, we are happy with what we achieved given the experience we have. One way we achieved this was by prioritizing low coupling of classes and high cohesion in our functions throughout development. This allowed for components (such as our Message, User, and Chat classes) to easily be reused in different parts of the project and also having functions available for general useage. In addition, our class diagram and other system design techniques implemented design patterns which promoted re-usability and were reflected in our implementations. A great example of this is the MQTT package used to implement the observer pattern (specifically the publisher/subscriber variant), which also improved our code re-use by preventing us from re-inventing this pattern.

Additionally, using existing modules such as PyQt5 and MQTT reduces the need for us to come up with our own solution for creating a way to send messages to specific users over a network or create our own UI from scratch. We used firebase for its authentication and database services, which meant we did not have to come up with a secure way to register and login users, store their emails and passwords securely, as well as set up our own database (which meant docker was not as required).

 ### **How many tasks are left in the backlog?**
 
We have many tasks left (> 10) in our Trello backlog. Fortunately, we implemented a priority system in our Trello board, which prioritizes more urgent tasks first. Therefore, most of the tasks left are low or medium priority. 

A link to our Trello board is here : https://trello.com/invite/b/HqdSQki6/ATTI5e4b8ea385bbca9b506227e79c537255723E5F60/kanban-dev-board
# CI/CD:
 ### **What testing strategies did you implement?  Comment on their degree of automation and the tools used. Would you (as a team) deal with testing differently in the future?  Make sure to ensure that your testing report is updated to reflect what's actually been done.**
 
 We used continuous testing by setting up GitHub actions to automatically run our unit tests and confirm all tests passed before a branch could be merged into main. Also, we implemented static testing by requiring a code review of every pull request before it could be merged. We tried out some pair programming when we met in person, and discussed our tests in our bi-weekly meetings. We adhered to test driven development by writing both white and black box testing methods first then writing code to meet the tests. We started to find out what worked best for us as a team as the project progressed.
 
  If we could do things differently we would have taken advantage of GitHub actions earlier, as it turned out to be very helpful. Also, figuring out how Pytest works and getting it to work correctly was a significant source of friction throughout our whole project, so we would have dedicated more time to testing than we did.
 ### **How did your branching workflow work for the team?  Were you successful in properly reviewing the code before merging as a team?**
The branching workflow worked well for our team. We tried to create branch per feature and got a bit better at estimating how much work should go into a branch as time went on. We later implemented the ability to connect pull requests and branches to our trello board to associate them with a specific task which helped us have one branch per task. Merging was set up so atleast one team member had to review the branch before it was merged, this worked very well and even caught a few problems.
 ### **How would your project be deployed?  Is it docker ready and tested?  Provide a brief description of the level of dockerization you have implemented and what would be required to deploy.**
 We could deploy our client UI interface by giving out a Python package, or compiling it all as an executable which would likely have version problems on different environments. Unfortunatly we did not have enough time to get Docker setup. In retrospect this was one of our greatest downfalls as many of our team members struggled with problems with their environments for the total length of the project.

# Reflections (Comment on the following items as a team):
Our team is great we all worked really hard to get something shippable and collabrated well with each other on all topic of discussion.
 ### **How did your project management work for the team?  What was the hardest thing and what would you do the same/differently the next time you plan to complete a project like this?**
The project management process for our team encouraged collaboration, communication and personalization. In our bi-weekly meetups, everyone decided the task they want to take on for that week. We had a shared google document (mostly used in the design phase) for everyone on our team to update as tasks were finished. For the implementation phase we mostly used our Trello board for communicating by assigning ourselves to different tasks. The hardest thing was making sure every team member was working on something at the same time, but no one was working on the same thing. Even with our task system there were a few instances where the same function was made twice, we believe working online asynchronously most of the time made communication more difficult. Our weekly meetings were very effective for communication, reflection and task distribution, so we would continue with those for next time. Next time we would attempt to have a single leader who distributes tasks, or have a more concrete process for distributing tasks to team members in an attempt to increase the cohesion of the team. We would also want to create sub-milestones to motivate our team to incrementally develop more often.
 ### **Do you feel that your initial requirements were sufficiently detailed for this project?  Which requirements did you miss or overlook?**
Yes we do feel that our initial requirements were sufficiently detailed for this project. Given our lack of domain knowledge our ability to make a detailed list initially was limited and the list was bound to be incrementally expanded through the agile process and our domain knowledge increased. The main requirements we missed were about technologies to be used (ie. we ended up using firebase for authentication and the database but we did not even know it existed in the initial phase) and the architecture of our system (we ended up using a client-server model)
 ### **What did you miss in your initial planning for the project (beyond just the requirements)?**
having global env for all of us aka 'docker' and other technologies could have been useful.
 ### **What process did you use (ie Scrum, Kanabn..), how was it managed, and what was observed?** 
  we technically used kanban, but had elements of scrum being that of group meetings and mini sprints, for things that were harder to do asynchronously.
 ### **As a team, did you encounter issues with different team members developing with different IDEs?  In the future, would the team change anything in regard to the uniformity of development environments?**
 we all used the same IDE to our knowledge. in the future having setup docker before starting code, now that we know about.
 ### **If you were to estimate the efforts required for this project again, what would you consider?  (Really I am asking the team to reflect on the difference between what you thought it would take to complete the project vs what it actually took to deliver it).**  
  we thought we made a fairly good set of requirements. but we still overreached by maybe a factor of 3-5
  simply considering if comparing to what a full polished project should look like. ie. deployable, pretty UI and a good UX.
 ### **What did your team do that you feel is unique or something that the team is especially proud of (was there a big learning moment that the team had in terms of gaining knowledge of a new concept/process that was implemented).**
  For us learning python and all sorts of new packages and external resources are really new for us so we research online and work our way through and in the end when we see our implementations working, we felt satisfying as well as get a sense of achievement. considering we have little experience with the language.
