
# LINK TO OUR VIDEO: https://www.youtube.com/watch?v=wgfr6D-bF_s&feature=youtu.be
# General Development:

 ### **What did your team build? Is it feature complete and running?**
Our team built Clack; a discord clone and desktop application. Clack uses a client-server model where it communicates with a MQTT server to ensure real-time updates of chats and friend requests. The program offers some of the features of Discord like adding/removing friends, and communication through graph chats. Additionally, all of our data is persistent and stored in a database. Clack is running great, however there are a few features which were not compelted in time. 

 ### **How many of your initial requirements that your team set out to deliver did you actually deliver (a checklist/table would help to summarize)?  Were you able to deliver everything or are there things missing?  Did your initial requirements sufficiently capture the details needed for the project?**
Here is a list of our initial requirements (✔️ means delivered, ❌ means not delivered):

INITIAL FUNCTIONAL REQUIREMENTS:
* Create Account ✔️
* Login ✔️
* Logout ✔️
* Add Friend
* Remove Friend
* Create Group
* View Online Users
* Kick Member
* Leave Group
* Add User To Group
* Send Message ✔️
* View Group Messages
* View Direct Messages
* Password Recovery ✔️

INITIAL NON-FUNCTIONAL REQUIREMENTS:
* Adhere to Kanban process ✔️
    * Use a Trello board ✔️
    * Have weekly meetings on Wednesday and Friday ✔️
* Program must run on Windows 10+ ✔️
* Program must be made to run in Python 3.10 ✔️
* Chat history must be stored indefinetly ✔️
* A message sent by another user must be received in <= 1 second ✔️
* Files and images can be shared
* All private information is kept confidential ✔️
* User account must be linked to a valid email address ✔️
* The system must be able to handle 1000+ online users at a time
* Viewing the online status of a friend should take <= 1 click to view
* System must not allow two accounts with the same username ✔️


We had too many initial requirements as our team underestimated the work required to complete them. The time constraint turned out to be too tight therefore there are a few functional and non-functional requirements we had to leave out. In general, the requirements were fairly accurate to the final system and captured some details well. However, in making this system all of us were venturing into a relatively new domain of development which limited our ability to choose technologies and architectures beforehand. It is clear a waterfall process would not be effective at all for this project and the flexibility of the agile development process was instrumental to our success.

All of us learned new technologies over the course of the development of the application as a result of agile. Such technologies include Python packages, Pytest, MQTT and Mosquitto, Firebase's authentication and realtime database services, PyQt5's UI library, PlantUML, and GitHub actions. Some of these technologies (particularly dealing with Python packages, Pytest, and GitHub actions) ended up taking large portions of time to debug (up to 80% of the time for some group members, particularly since any errors generated by our Python packages importing one another would throw "module X does not exist," which is not particularly helpful when the solution is that we had not installed the application yet using python or we were missing an init file).
 ### **What is the architecture of the system?  What are the key components?   What design patterns did you use in the implementation?  This needs to be sufficiently detailed so that the reader will have an understanding of what was built and what components were used/created.  You will need to reflect on what you planned to build vs what you built.**

![our architecture diagram](clack_architecture_diagram.png)

Our architecture consists of four key components (only two of which we needed to program):

* The Client, which is what the user will interact with. Its responsibilities include sending messages over the MQTT network to other clients, querying the database to populate the session's variables on log in (since storing every user's chat messages locally is a security risk), and having an interface for the user to interact with the underlying system
* The MQTT broker, which simply forwards any messages to whoever is subscribed to the topic
* The Listener Server, who's responsibility is to listen for any messages being sent over the MQTT network and save them to the database (that way offline users can receive messages). Having the Listener Server perform inserts on the database as opposed to the Client improves security by preventing a hacked client to insert bad data into the database
* Firebase, which is responsible for holding our database and performing the authentication of users. The Client uses the authentication service of Firebase to authenticate users as well as query the database. The Listener Server performs inserts on the database

![our Client class diagram](../diagrams/out/class_diagram/class_diagram.png)

![our Listener Server class diagram](../diagrams/out/class_diagram_serverlistener/class_diagram_serverlistener.png)

The design patterns we used are the following:

* A singleton for the database connection to avoid creating a new connection to the database every time we want to use it. This improves performance by reducing network traffic
* A singleton for the MQTT connection to avoid creating a new connection to the MQTT network every time we want to use it. This improves performance by reducing network traffic
* A singleton for the Session Manager to ensure there is only one session at any given time (the session class holds the variable for whoever is logged in and all of their chats and is what the UI interacts with), and avoiding creating a new session every time something needs to be displayed improves performance considerably (the session's variables would need to be re-populated each time otherwise). Additionally, the SessionManager will automatically refresh the session since Firebase will automatically close the session after one hour
* A publisher/subscriber model for the MQTT broker, which allows clients to subscribe to chatrooms (or other topics, like the statuses of their friends) in a low-coupling fashion, improving performance and reducing complexity

 ### **What degree and level of re-use was the team able to achieve and why?**

The degree and level of re-use we achieved was about average we think, it definitely could be improved, however, we are happy with what we achieved given the experience we have. One way we achieved this was by prioritizing low coupling of classes and high cohesion in our functions throughout development. This allowed for components (such as our Message, User, and Chat classes) to easily be reused in different parts of the project and also having functions available for general usage. In addition, our class diagram and other system design techniques implemented design patterns which promoted re-usability and were reflected in our implementations. A great example of this is the MQTT package used to implement the observer pattern (specifically the publisher/subscriber variant), which also improved our code re-use by preventing us from re-inventing this pattern.

Additionally, using existing modules such as PyQt5 and MQTT reduces the need for us to come up with our own solution for creating a way to send messages to specific users over a network or create our own UI from scratch. We used Firebase for its authentication and database services, which meant we did not have to come up with a secure way to register and login users, store their emails and passwords securely, as well as set up our own database (which meant Docker was not as required).

 ### **How many tasks are left in the backlog?**
 
We have many tasks left (> 10) in our Trello backlog. Fortunately, we implemented a priority system in our Trello board, which prioritizes more urgent tasks first. Therefore, most of the tasks left are low or medium priority. 

A link to our Trello board is here : https://trello.com/invite/b/HqdSQki6/ATTI5e4b8ea385bbca9b506227e79c537255723E5F60/kanban-dev-board
# CI/CD:
 ### **What testing strategies did you implement?  Comment on their degree of automation and the tools used. Would you (as a team) deal with testing differently in the future?  Make sure to ensure that your testing report is updated to reflect what's actually been done.**
 
 We used continuous testing by setting up GitHub actions to automatically run our unit tests and confirm all tests passed before a branch could be merged into main (this also lets us confirm that someone's tests actually _do_ pass). Also, we implemented static testing by requiring a code review of every pull request before it could be merged. We tried out some pair programming when we met in person, and discussed our tests in our bi-weekly meetings. We adhered to test driven development by writing both white and black box testing methods first then writing code to meet the tests. We started to find out what worked best for us as a team as the project progressed.
 
  If we could do things differently we would have taken advantage of GitHub actions earlier, as it turned out to be very helpful. Also, figuring out how Pytest works and getting it to work correctly was a significant source of friction throughout our whole project, so we would have dedicated more time to testing than we did.
 ### **How did your branching workflow work for the team?  Were you successful in properly reviewing the code before merging as a team?**
The branching workflow worked well for our team. We tried to create branch per feature and got a bit better at estimating how much work should go into a branch as time went on. We later implemented the ability to connect pull requests and branches to our Trello board to associate them with a specific task which helped us have one branch per task. Merging was set up so at least one team member had to review the branch before it was merged, this worked very well and even caught a few problems.
 ### **How would your project be deployed?  Is it docker ready and tested?  Provide a brief description of the level of dockerization you have implemented and what would be required to deploy.**
 We could deploy our client UI interface by giving out a Python package, or compiling it all as an executable which would likely have version problems on different environments. Unfortunately, we did not have enough time to get Docker setup. In retrospect this was one of our greatest downfalls as many of our team members struggled with problems with their environments for the total length of the project. Other than that, Docker was not needed for a the database as firebase managed and deployed our database, meaning we were not required to use Docker to deploy our application.

# Reflections (Comment on the following items as a team):
 ### **How did your project management work for the team?  What was the hardest thing and what would you do the same/differently the next time you plan to complete a project like this?**
The project management process for our team encouraged collaboration, communication and personalization. In our bi-weekly meetups, everyone decided the task they want to take on for that week. Any changes to our tasks (like if we completed a task, started a new one, or encountered a road block) would be mentioned on our group chat on Discord, help keeping all group members updated. We had a shared Google document (mostly used in the design phase) for everyone on our team to update as tasks were finished. For the implementation phase we mostly used our Trello board for communicating by assigning ourselves to different tasks. The hardest thing was making sure every team member was working on something that did not need to depend on other people's tasks, as most of us had conflicting schedules which presented little time to work on it together. Even with our task system there were a few instances where the same function was made twice, we believe working online asynchronously most of the time made communication more difficult. Our weekly meetings were very effective for communication, reflection and task distribution, so we would continue with those for next time. Next time we would attempt to have a single leader who distributes tasks, or have a more concrete process for distributing tasks to team members in an attempt to increase the cohesion of the team. We would also want to create sub-milestones to motivate our team to create increments more regularly.
 ### **Do you feel that your initial requirements were sufficiently detailed for this project?  Which requirements did you miss or overlook?**

Yes we do feel that our initial requirements were sufficiently detailed for this project. Given our lack of domain knowledge our ability to make a detailed list initially was limited and the list was bound to be incrementally expanded through the agile process and our domain knowledge increased. The main requirements we missed were about technologies to be used (ie. we ended up using Firebase for authentication and the database but we did not even know it existed in the initial phase) and the architecture of our system (we ended up using a client-server model). We also missed requirements for our UI, we did not have a big idea of what the form of our UI would even be, whether a command-line or a web form.

 ### **What did you miss in your initial planning for the project (beyond just the requirements)?**
It would have been beneficial for us to research technologies and architectures we could use for our domain. Our class diagrams and sequence diagrams mostly ended up being scrapped as we discovered new knowledge. We also missed clear roles and responsibilities of team members, we all worked on everything and some sort of order may have benefited us.  Finally we did not clarify how our development process would be conducted, ie. we used test driven development, and code reviews, but this was not mentioned concretely in our initial plan.
 ### **What process did you use (ie Scrum, Kanabn..), how was it managed, and what was observed?** 
  We initially set out to use Kanban, but it ended up being a combination of Kanban and Scrum (Scrumban?). We managed this by using Trello for our Kanban board, with backlog, in-progress and done columns. The tasks on our board were sorted by priority (low, medium, high) and associated with GitHub branches or pull requests. On the scrum side we managed to have 2 group meetings every week which was a mix of a reflection, retrospective and deciding on what to do going forward. We also worked on the project in the meetings if we had time which could be considered mini sprints.
 ### **As a team, did you encounter issues with different team members developing with different IDEs?  In the future, would the team change anything in regard to the uniformity of development environments?**
Fortunately, everyone used Visual Studio Code as their IDE. In addition, we specified the version of Python everyone should have installed to reduce environment incompatibilities. Even with our similar environments, we somehow did have a bunch of problems with our environments still. In the future we would have just setup Docker before even starting to code, and it would have saved us a lot of time.
 ### **If you were to estimate the efforts required for this project again, what would you consider?  (Really I am asking the team to reflect on the difference between what you thought it would take to complete the project vs what it actually took to deliver it).**  
We thought we made a fairly good set of requirements. During our initial discussion we even trimmed down some of our requirements into stretch goals to reduce our scope. We still underestimated the work by a large amount. Going forward, we would consider if we are unfamiliar with the domain, and if we are, the estimated time should go way up. In addition, we would consider how much work goes into have a polished product versus a barebones prototype. We expected to have a product with a polished UI but ended up working on the internal system too long to have any time to work on the UI.
 ### **What did your team do that you feel is unique or something that the team is especially proud of (was there a big learning moment that the team had in terms of gaining knowledge of a new concept/process that was implemented).**
 Most of the team only had experience coding in one or two Python files at a time. To create such an interconnected system with module imports coming from such little knowledge we felt was a big achievement in itself and is something to be proud of. Also, learning about the client-server model was a big learning moment for us, as we initially only had a clientside class diagram, and later on we realized that a serverside diagram is needed as we thought through the process of client to client communication. Things like these seem easy on paper, but in practice there is a lot of learning to be had. Though, by far the biggest learning moment we had is probably from debugging since we spent so much time debugging our Python environments we are practically Python IT guys now.
